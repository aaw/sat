#!/usr/bin/python3

# Usage: python3 pigeonhole.py p h
#
# Generates a boolean formula that describe an assignment of p pigeons to h
# holes with no two pigeons in a hole. Satisfiable exactly when p <= h.

import io
import itertools
import sys

def pigeonhole(p, h):
    # For pigeons pp in 0..p-1 and holes hh in 0..h-1, variable
    # x = pp*h + hh + 1 represents "pigeon pp is in hole hh".
    def var(pp,hh):
        return pp*h + hh + 1

    clauses = []
    for pp in range(p):
        clause = []
        # Each pigeon p must be in some hole.
        for hh in range(h):
            clause.append(var(pp,hh))
        clauses.append(clause)

    for pp in itertools.combinations(range(p), 2):
        for hh in range(h):
            # No two pigeons can be in the same hole.
            clauses.append([-var(pp[0],hh), -var(pp[1],hh)])

    buffer = io.StringIO()
    for c in clauses:
        buffer.write((" ".join(["{}"] * len(c)) + " 0\n").format(*c))

    return 'p cnf {0} {1}\n'.format(p*h, len(clauses)) + buffer.getvalue()

if __name__ == '__main__':
    try:
        assert(len(sys.argv) == 3)
        p = int(sys.argv[1])
        h = int(sys.argv[2])
        assert(p > 0)
        assert(h > 0)
    except:
        print('Usage: "pigeonhole.py p h" for non-negative integers p and h')
        sys.exit(-1)
    print("c Generated by pigeonhole.py {0}".format(' '.join(sys.argv[1:])))
    print("c Generator source: github.com/aaw/sat/gen/pigeonhole.py")
    if p <= h:
        print("c label:satisfiable")
    else:
        print("c label:unsatisfiable")
    print(pigeonhole(p,h))
