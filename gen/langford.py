#!/usr/bin/python3

# Usage: python3 langford.py n [--compressed]
#
# Generates the Langford clauses described in Knuth 7.2.2.2 (the specific case
# of n = 3 is described in (12)). These clauses are satisfiable exactly when
# n mod 4 = 0 or 3. If --compressed is specified, the alternate, smaller
# encoding of Knuth's symmetric S function is used, resulting in fewer clauses
# but more variables.
#
# The Langford clauses encode the following problem: can two ones, two twos,
# ... two n's be placed in a sequence of length 2n such that there are exactly
# k numbers between each pair of numbers k for each k in [1,n]? `langford.py 4`
# produces a satisfiable formula, for example, since the sequence 41312432
# exists.

import io
import math
import sys

# Return triples representing options in the set cover problem as in (11).
# (x, y, z) means digit x is placed in slots y and z.
def options(n):
    for d in range(1, n+1):
        for i in range(1, 2*n-d):
            # Use symmetry shortcut for the d == n case, just like Knuth
            # mentions. I guess the real reason to do this is to generate unit
            # clauses which create examples that DPLL is faster on than basic
            # backtracking.
            if d != n or i <= (2*n - i - d - 1):
                yield((d,i,i+d+1))

# Given a list of variables, generate a boolean formula that is satisfied when
# at most one of the variables it true. The formula generated is just a big
# disjunction specifying that out of every pair of variables, at least one is
# false.
def at_most_one(x):
    clauses = []
    for i in range(0, len(x)-1):
        for j in range (i+1, len(x)):
            clauses.append((-x[i],-x[j]))
    return clauses

# Given a list of variables, generate a boolean formula that is satisfied when
# at most one of the variables is true. Let S(x_1, x_2, ..., x_n) represent the
# boolean function that returns true iff at most one of x_1, x_2, ..., x_n is
# true. Then S satisfies:
#
# S(x_1, x_2, ..., x_n) =
#     Exists a t such that S(x_1, ..., x_j, t) AND S(-t, x_j+1, ..., x_n)
#
# When n > 4, this yields a boolean formula with fewer clauses but more
# variables than the formula produced by at_most_one above. The function below
# returns a function that implements this scheme. Since this scheme introduces
# new variables, next_var must be provided as an integer from which new
# variables can be generated. Values >= next_var may be used for new variables.
#
# The function below returns a function that accepts a list of variables and
# returns a list of clauses that contain at least the list of original variables
# and are satisfiable iff at most one of the original variables is true.
def compressed_at_most_one(next_var):
    nv = next_var - 1
    def f(x):
        nonlocal nv
        if len(x) <= 4:
            return at_most_one(x)
        else:
            nv += 1
            split = nv
            return f(x[:len(x)//2] + [split]) + \
                f([-split] + x[len(x)//2:])
    return f

def langford(n, compressed):
    opts = [x for x in options(n)]
    clauses = []
    S = at_most_one
    if compressed:
        S = compressed_at_most_one(len(opts)+1)
    # Each pair of digits must be selected exactly once.
    for i in range(1, n+1):
        cs = [j+1 for j,x in enumerate(opts) if x[0] == i]
        clauses.append([tuple(cs)]) # At least one
        clauses.append(S(cs)) # At most one
    # Each index selection must be used exactly once.
    for i in range(1, 2*n+1):
        cs = [j+1 for j,x in enumerate(opts) if i in (x[1], x[2])]
        clauses.append([tuple(cs)]) # At least one
        clauses.append(S(cs)) # At most one
    clauses = set(x for sublist in clauses for x in sublist if len(x) > 0)
    buffer = io.StringIO()
    for c in clauses:
        buffer.write((" ".join(["{}"] * len(c)) + " 0\n").format(*c))

    mv = max(abs(var) for clause in clauses for var in clause)
    return 'p cnf {0} {1}\n'.format(mv, len(clauses)) + buffer.getvalue()

if __name__ == '__main__':
    try:
        assert(2 <= len(sys.argv) <= 3)
        n = int(sys.argv[1])
        assert(n > 1)
        compressed = len(sys.argv) == 3 and sys.argv[2] == '--compressed'
    except:
        print('Usage: "langford.py n [--compressed]" for integer n')
        sys.exit(-1)
    print("c Generated by langford.py {0}".format(' '.join(sys.argv[1:])))
    print("c Generator source: github.com/aaw/sat/gen/langford.py")
    if n % 4 in (0,3):
        print("c label:satisfiable")
    else:
        print("c label:unsatisfiable")
    print(langford(n, compressed))
